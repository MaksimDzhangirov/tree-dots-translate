# Хранение общих скриптов в GitLab CI

[Данная статья является переводом. Оригинал можно найти по ссылке](https://threedots.tech/post/keeping-common-scripts-in-gitlab-ci/)

Милош Смолка. Технический руководитель [Karhoo](https://www.karhoo.com/). Соучредитель
[Three Dots Labs](https://threedotslabs.com/). Создатель [Watermill](https://github.com/ThreeDotsLabs/watermill).

Этой статьёй я хотел бы начать цикл, посвященный советам по CI, ориентированных 
в основном на GitLab, так как это мой инструмент для вещей, связанных с CI/CD.
Однако я уверен, что большинство из них можно легко применить к другим CI 
системам.

Хотя GitLab отлично справляется со многими вещами (размещение репозитория и 
сопутствующие вещи, такие как MR, пайплайны, доски задач и т. д.), в некоторых 
областях ему иногда не хватает более специализированных функций. Из-за 
интенсивного использования конвейеров в моих проектах мне часто приходилось 
искать обходные пути и хитрые приемы. Поэтому я хотел бы поделиться некоторыми 
из них сейчас, основываясь на своем опыте.

## Проблема

Пример CI определения может выглядеть примерно следующим образом:

```yml
stages:
  - test
  - build
  - deploy
test:
  image: golang:1.11
  stage: test
  script:
    - go test ./...
    - go vet ./...
build:
  image: golang:1.11
  stage: build
  script:
    - go build -o ./bin/my-app ./cmd/my-app
  artifacts:
    paths:
      - bin/
deploy:
  stage: deploy
  script:
    - ... # загрузить куда-то bin/
```

У меня бывают некоторые проблемы с использованием таких bash команд. Посмотрите, 
что происходит, когда вам нужно что-то изменить в одной из ваших задач:

1. Вам нужно запушить новый коммит в репозиторий приложения, **запустив полный 
   конвейер** для проекта.
2. Ваши изменения **не будут распространяться на другие ветки**, если только ваш 
   коммит из `master` не будет объединен другими разработчиками.
3. Ваши изменения повлияют **только на этот репозиторий.** Если вы поддерживаете 
   несколько похожих проектов, вам необходимо внести изменения во все из них.

## Репозиторий общих скриптов

Одна из вещей, которую я упустил, когда начинал работать с конвейерами 
GitLab, — это место для общих скриптов, которые можно было бы использовать в 
нескольких репозиториях. В то время [include](https://docs.gitlab.com/ee/ci/yaml/#include) еще не был доступен, но даже 
сейчас это вряд ли решает проблему для меня.

Повторное использование частей YAML определения — это одно, а другое — повторное
использование стандартных сценариев во всех ваших проектах. Я бы предпочел, 
чтобы такие вещи, как «сборка приложения», «упаковка приложения», 
«развертывание приложения», были однострочными в конвейере.

Я также чувствую, что это хорошо вписывается в мышление DevOps: операторы 
готовят сценарии, которые легко использовать разработчикам. Скрипты 
разрабатываются с использованием тех же передовых практик, что и код самого 
приложения: с проверками кода и собственным конвейером, включая модульные тесты 
и статические проверки.

Я обычно заканчиваю смесью bash и Python скриптов. Bash хорошо работает для 
простых сценариев, но для более сложных вещей используется Python (или другой
скриптовый язык, который вам нравится), избавляющий вас от головной боли в будущем. 
Python обычно проще читается и другими людьми, но имейте в виду, что он может 
быть не включен в каждый образ докера, который вы будете использовать в своей 
работе.

## Реализация

Идея довольно проста: извлекать репозиторий скриптов каждый раз, когда 
запускается задача. Это должно быть так же просто, как добавить глобальные 
настройки в ваш .gitlab-ci.yml:

```yml
variables:
  SCRIPTS_REPO: https://gitlab.com/threedotslabs/ci-scripts
before_script:
  - export SCRIPTS_DIR=$(mktemp -d)
  - git clone -q --depth 1 "$SCRIPTS_REPO" "$SCRIPTS_DIR"
```

Вы также можете переместить переменные в переменные CI/CD проекта. Или 
`include` этот конфиг из другого места. Или используйте свои собственные 
образы докеров с готовым репозиторием скриптов и запустить в нем `git pull`. 
Основная идея остается прежней.

> Передача параметра `--depth 1` приводит к _не глубокому клонированию_ 
> репозитория, т. е. усеченному до самой последнего коммита из ветки `master`.
> Благодаря этому накладные расходы на каждую задачу минимальны. 
> [Узнайте больше в документации](https://git-scm.com/docs/git-clone#git-clone---depthltdepthgt).

## Пример скрипта

Допустим, у вас есть несколько приложений на Golang, и вы бы предпочли единый 
процесс сборки для всех из них.

Зачем вам это нужно, если простой сборки на ходу должно быть достаточно? 
Например, вы можете захотеть зафиксировать номер версии в каждый из ваших сервисов: 
обычно полезно знать, какую версию вы используете! Включение этого в общий 
сценарий гарантирует, что ни одно из ваших приложений не пропустит этот шаг.

В следующей статье я покажу вам, как генерировать версии [semver](https://semver.org/) для коммитов. 
На данный момент мы будем использовать хэш `git commit` в качестве номера 
версии.

```shell
#!/bin/bash
# Build generic golang application.
#
# Example:
#	build-go cmd/server example-server pkg.version.Version
set -e

if [ "$#" -ne 3 ]; then
	echo "Usage: $0 <package> <target_binary> <version_var>"
	exit 1
fi

readonly package="$1"
readonly target_binary="$2"
readonly version_var="$3"

readonly bin_dir="$CI_PROJECT_DIR/bin/"

mkdir -p "$bin_dir"
go build -ldflags="-X $version_var=$CI_COMMIT_SHA" -o "$bin_dir/$target_binary" "$package"
```

> Не забудьте про ключ -e, иначе ваши bash скрипты могут незаметно завершиться 
> ошибкой и привести к трудным для поиска ошибкам.

Этот сценарий ожидает, что полученный двоичный файл будет храниться в каталоге
`bin`. Это еще одна вещь, которую вы можете захотеть сделать согласованной во 
всех репозиториях.

> Обратите внимание, что я использовал переменные `CI_`, [предоставляемые GitLab](https://docs.gitlab.com/ee/ci/variables/).
> Хотя они действительно упрощают выполнение сценариев, это требует более сложного 
> тестирования, поскольку вам необходимо настроить некоторые переменные среды 
> перед запуском сценариев локально. Если вы предпочитаете более явный подход, 
> просто передайте эти переменные в качестве аргументов вашему сценарию.

Этот скрипт должен быть помещен в ваш [репозиторий скриптов](https://gitlab.com/threedotslabs/ci-scripts). Не забудьте 
установить права на выполнение (`chmod +x`).

Последнее, что вам нужно сделать, это использовать скрипт в [репозитории 
вашего приложения](https://gitlab.com/threedotslabs/ci-examples):

```yml
build:
  image: golang:1.11
  stage: build
  script:
    - $SCRIPTS_DIR/golang/build . example-server main.Version
  artifacts:
    paths:
      - bin/
```

На этом всё! Теперь ваши сценарии всегда должны быть актуальными в ваших 
репозиториях. Конечно, эта настройка не будет иметь особого смысла, если вы 
используете только один репозиторий, так что имейте это ввиду. Не усложняйте, 
если можете.

## Аутентификация

Если вы используете приватный репозиторий для своих скриптов, вам потребуется 
добавить некоторую форму аутентификации, чтобы клонировать его. Это можно 
сделать либо с помощью [токенов развертывания](https://docs.gitlab.com/ee/user/project/deploy_tokens/), либо с помощью [ключей 
развертывания SSH](https://docs.gitlab.com/ee/ci/ssh_keys/).

Использование токенов развертывания немного проще, поэтому давайте посмотрим 
на это в действии.

1. В репозитории скриптов: создайте новый токен развертывания. Вы найдете его 
   в разделе `Settings -> Repository -> Deploy tokens`.
2. В репозитории приложения: добавьте сгенерированного пользователя и токен в 
   качестве новых переменных с именами `SCRIPTS_USER` и `SCRIPTS_TOKEN`. Сделать 
   это можно в разделе `Settings -> CI/CD -> Variables`.
3. Измените переменную `SCRIPTS_REPO` в определении CI вашего приложения:

```yml
variables:
  SCRIPTS_REPO: https://$SCRIPTS_USER:$SCRIPTS_TOKEN@gitlab.com/threedotslabs/ci-scripts
```

> Управление секретными параметрами в нескольких проектах упрощается, если вы 
> добавляете переменные на уровне группы.

## Тестирование изменений

Если вы раньше работали с несколькими репозиториями, вы уже должны знать, что 
это добавляет некоторые накладные расходы на синхронизацию. Например, отправка 
неработающего скрипта в ветку `master` может привести к поломке сборок во всех 
ваших проектах. Вот почему код ревью и unit тесты очень приветствуются.

Если unit тестирование скриптов сложно или просто невозможно, вы можете сначала 
попробовать протестировать их на ветках, прежде чем объединять их в `master`.
Вам нужно будет просто выполнить checkout выбранной ветки после клонирования.
Что здорово, вы можете повторить задачу завершившуюся неудачей таким образом сразу после 
внесения изменений в скрипт, без повторного запуска всего конвейера.

## Что с Makefiles?

Перемещение всех команд bash в `Makefile` может привести в порядок ваше CI 
определение и позволит разработчикам выполнять те же проверки и тесты, которые 
будут выполняться в конвейере. Например, вы можете ввести команду `make test`, 
который будет запускать unit тесты, `make lint` для статических проверок и так 
далее.

К сожалению, это будет означать дублирование `Makefile` во всех ваших 
репозиториях, и на самом деле это не решит проблемы, упомянутые выше. Makefiles 
также имеют свои особенности, поэтому лучше убедитесь, что вы знаете, что 
делаете, иначе вы можете столкнуться с непредвиденными проблемами (например, 
молчаливое завершение при ошибках).

## Подведение итогов

Хотя сценарий, который мы использовали, действительно тривиален, он показывает, 
как эту интеграцию можно использовать для хранения всех сценариев, связанных с 
CI, в одном месте. В следующих статьях я покажу более сложные примеры, так что 
следите за обновлениями!

Если у вас есть какие-либо вопросы или вы хотите поделиться другими 
идеями для аналогичного настройки рабочего процесса, напишите мне в Twitter.

## Полезные ссылки

* [пример репозитория со скриптами](https://gitlab.com/threedotslabs/ci-scripts)
* [пример репозитория приложения](https://gitlab.com/threedotslabs/ci-examples)
* [Go инструменты и Gitlab: как осуществлять непрерывную интеграцию как эксперт](https://about.gitlab.com/2017/11/27/go-tools-and-gitlab-how-to-do-continuous-integration-like-a-boss/)
* [Настраиваем ваши задачи с помощью .gitlab-ci.yml](https://docs.gitlab.com/ee/ci/yaml)