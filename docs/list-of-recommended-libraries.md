# Go библиотеки, никогда нас не подводившие: 22 библиотеки, о которых вам нужно знать

[Данная статья является переводом. Оригинал можно найти по ссылке](https://threedots.tech/post/best-go-framework/)

Роберт Лащак. Главный инженер [SlashID](http://slashid.dev/). Соучредитель
[Three Dots Labs](https://threedotslabs.com/).
Создатель [Watermill](https://github.com/ThreeDotsLabs/watermill).

Была ли у вас ситуация, когда вы потеряли кучу времени на поиск Go библиотеки,
которая вам нужна? Теоретически вы можете просмотреть список, такой как
Awesome Go, или сделать выбор на основе GitHub звезд. Но [Awesome Go](https://github.com/avelino/awesome-go) 
содержит более 2600 библиотек, и популярность не всегда является лучшим 
показателем качества библиотек. **Я часто размышлял, что было бы здорово 
если бы была страница, где я мог бы найти самые лучшие и проверенные в 
боевых условиях библиотеки, которые можно было бы использовать в своем 
проекте.** Так как мы с Милошем не нашли такой страницы, мы решили 
её создать.

![](images/list-of-recommended-libraries/library-gopher.svg)

Основываясь на нашем опыте руководства несколькими командами Go и работы 
над различными проектами, в том числе связанные со сложными 
финансами, здравоохранением и безопасностью, мы порекомендуем 
инструменты, которые будут хорошо работать для разных проектов.

Кроме самого списка с библиотеками, мы также хотим показать вам некоторые 
неочевидные варианты использования этих инструментов и библиотек. Однако 
важно отметить, что большинством этих инструментов можно злоупотреблять.
Мы добавили несколько распространенных антипаттернов, чтобы помочь вам 
избежать подобных ошибок.

> Приведенный ниже список нельзя назвать не предвзятым. **Мы хотели добавить
> только те библиотеки, которые мы использовали в реальных продакшен 
> системах. Благодаря этому мы рекомендуем только те библиотеки, в 
> которых уверены на 100%.** К сожалению, наши сутки ограничены 24 часами, 
> поэтому проверить все доступные библиотеки невозможно.
> 
> **Если вы знаете о каких-то библиотеках, которые мы должны включить в 
> этот список, сообщите нам об этом в комментариях!** Периодически мы будем
> обновлять список, дописывая в него новые полезные инструменты.

## Содержание

* [HTTP](list-of-recommended-libraries.md#HTTP)
  * [Маршрутизаторы](list-of-recommended-libraries.md#Маршрутизаторы) 
  * [Middlewares](list-of-recommended-libraries.md#middlewares)
  * [Отправка статических файлов](list-of-recommended-libraries.md#Отправка статических файлов)
  * [OpenAPI](list-of-recommended-libraries.md#openapi)
  * [Генерация Go сервера и клиентов](list-of-recommended-libraries.md#Генерация Go сервера и клиентов)
  * [Бонус: клиент для JavaScript/TypeScript](list-of-recommended-libraries.md#Бонус-клиент-для-JavaScriptTypeScript)
* [Альтернативные виды взаимодействия](list-of-recommended-libraries.md#Альтернативные виды взаимодействия)
  * [gRPC](list-of-recommended-libraries.md#grpc)
  * [Обмен сообщениями](list-of-recommended-libraries.md#Обмен сообщениями)
* [База данных](list-of-recommended-libraries.md#База данных)
  * [SQL](list-of-recommended-libraries.md#sql) 
  * [Миграции](list-of-recommended-libraries.md#Миграции)
* [Наблюдаемость](list-of-recommended-libraries.md#Наблюдаемость) 
  * [Логирование](list-of-recommended-libraries.md#Логирование)
  * [Метрики и трассировка](list-of-recommended-libraries.md#Метрики и трассировка)
* [Конфигурация](list-of-recommended-libraries.md#Конфигурация)
  * [Переменные окружения](list-of-recommended-libraries.md#Переменные окружения)
* [Создание интерфейса командной строки](list-of-recommended-libraries.md#Создание интерфейса командной строки)
  * [Создание CLI библиотек](list-of-recommended-libraries.md#Создание CLI библиотек)
* [Тестирование](list-of-recommended-libraries.md#Тестирование)
  * [Утверждения](list-of-recommended-libraries.md#Утверждения)
  * [Имитация](list-of-recommended-libraries.md#Имитация)
* [Разное](list-of-recommended-libraries.md#Разное)
  * [Поддержка дополнительных типов](list-of-recommended-libraries.md#Поддержка дополнительных типов)
  * [Ошибки](list-of-recommended-libraries.md#Ошибки)
* [Полезные инструменты](list-of-recommended-libraries.md#Полезные инструменты)
  * [Разное](list-of-recommended-libraries.md#Разное)
  * [Перезагрузка кода «на лету»](list-of-recommended-libraries.md#Перезагрузка кода на лету)
  * [Линтер](list-of-recommended-libraries.md#Линтер)
  * [Форматтеры](list-of-recommended-libraries.md#Форматтеры)
* [Примеры проектов](list-of-recommended-libraries.md#Примеры проектов)
  * [DDD и чистая архитектура](list-of-recommended-libraries.md#DDD и чистая архитектура)
  * [Общего назначения](list-of-recommended-libraries.md#Общего назначения)
* [Резюме](list-of-recommended-libraries.md#Резюме)

## HTTP

### Маршрутизаторы

Как я упоминал в своей [предыдущей статье](the-best-go-framework-no-framework.md), для
долгосрочных проектов обычно лучше использовать библиотеки, а не 
фреймворки. Одним из наиболее фундаментальных компонентов любого сервиса 
является HTTP-маршрутизатор. Хотя технически возможно создать приложение 
без него, используя [http-пакет](https://pkg.go.dev/net/http) стандартной 
библиотеки, его возможности маршрутизации ограничены. Использование 
специально созданного для решения этой задачи маршрутизатора значительно 
облегчит Вашу жизнь.

> ❌ **Антипаттерн: Фреймворки в Go**
> 
> Если библиотека, которую вы планируете использовать, влияет на то, как
> вы создаёте свои модели предметной области, вероятно, это фреймворк, а 
> не маршрутизатор.
> 
> Вместо этого мы рекомендуем использовать легковесные маршрутизаторы. 
> Узнайте больше о рисках использования фреймворка из моей 
> [предыдущей статьи](the-best-go-framework-no-framework.md).

Исходя из принципов работы, функционал маршрутизатора ограничен 
маршрутизацией запросов к соответствующему обработчику. Все 
нестандартные функции, такие как CORS, CSRF, обработка ошибок, HTTP 
логирование и авторизация (которые обычно реализуют фреймворки), 
предоставляются middlewareами, которые можно использовать многоразово.
Я рекомендую некоторые из них в [разделе, посвященном middleware](list-of-recommended-libraries.md#middlewares).

В большинстве проектов я использую одну из двух библиотек для 
маршрутизации: `Echo` или `chi`. Они обе являются отличными маршрутизаторами с
разными характеристиками. Они идеально работают с генерацией кода, 
используя [OpenAPI](list-of-recommended-libraries.md#openapi).

✅ Echo [Страница на GitHub](https://github.com/labstack/echo) [Документация](https://echo.labstack.com/guide/) [Примеры использования](https://echo.labstack.com/cookbook/)

По сравнению с `chi`, `Echo` предлагает использовать свою, нестандартную 
сигнатуру обработчика `*http.Request`. Некоторым это может показаться 
недостатком, но я думаю, что это помогает писать менее подверженные 
ошибкам HTTP обработчики.

Если вы какое-то время писали на Go, то наверняка хотя бы раз 
совершали эту ошибку:

```go
func someHandler(w http.ResponseWriter, r *http.Request) {
	err := foo()
	if err != nil {
		w.WriteHeader(http.StatusBadRequest) 
		// Вы забыли оператор return здесь, поэтому будет выполнена 
		//функция bar() 
	}

	bar()
}
```

`Echo` заставляет вас возвращать ошибку:

```go
func someHandler(c echo.Context) error {
	err := foo()
	if err != nil {
		return err
	}
	
	bar()
	
	return c.NoContent(http.StatusNoContent)
}
```

Преимуществом `Echo` является возможность определить собственный 
обработчик ошибок. Невозможно сделать это таким же образом с помощью 
`chi`.

Более подробное описание использования и примеры смотри в документации
`Echo`.

✅ chi [Страница на GitHub](https://github.com/go-chi/chi) [Документация](https://pkg.go.dev/github.com/go-chi/chi) [Примеры использования](https://github.com/go-chi/chi/tree/master/_examples)

В отличие от `Echo` функции-обработчики `chi` совместимы со стандартной 
библиотекой. Для некоторых это может быть преимуществом; а для других
— недостатком — вы должны решить сами.

Что у `chi` реализовано лучше, чем у `Echo`, так это формат определения 
маршрутов и их группировка. Это позволяет вам лучше контролировать middleware
для пути или подпути.

```go
r.Route("/articles", func(r chi.Router) {
    r.With(paginate).Get("/", ListArticles)
    r.Post("/", CreateArticle)       // POST /articles
    r.Get("/search", SearchArticles) // GET /articles/search
    
    r.Route("/{articleID}", func(r chi.Router) {
        r.Use(ArticleCtx)            // Загружаем *Article в контекст запроса
        r.Get("/", GetArticle)       // GET /articles/123 
        r.Put("/", UpdateArticle)    // PUT /articles/123 
        r.Delete("/", DeleteArticle) // DELETE /articles/123
    })
    
    // GET /articles/whats-up
    r.With(ArticleCtx).Get("/{articleSlug:[a-z-]+}", GetArticle)
})
```

Весь исходный код: [github.com/go-chi/chi/_examples/rest/main.go](https://github.com/go-chi/chi/blob/0fe6bf1ba3ac601700b7993bc4c62f6c5f707932/_examples/rest/main.go#L83)

> ❌ **Антипаттерн: не стоит выбирать инструменты только на основе бенчмарков**
> 
> Некоторые разработчики выбирают библиотеки на основе результатов 
> тестов. Это рискованный подход, потому что чрезмерная оптимизация 
> производительности приводит к ухудшению API и ограниченному набору 
> функций. В большинстве случаев различия в производительности 
> незначительны в реальных сценариях использования.
> 
> Даже если для некоторых приложений это может иметь значение, для 
> большинства приложений это не имеет большого значения. Выполнение 
> всего одного дополнительного запроса к базе данных или масштабирование 
> сервиса путём увеличения выделяемых ему ресурсов может значительно 
> улучшить производительность.
> 
> Если производительность для вас не так критична, вам следует отдать 
> предпочтение другим характеристикам, таким как простота использования 
> и число предоставляемых функций.


### Middlewares

HTTP middlewares могут помочь реализовать вам такие функции как CORS, 
CSRF, обработка ошибок, HTTP логирование, авторизация и т. д.

`Echo` и `chi` предоставляют свой набор middlewares:

* [Echo middlewares](https://echo.labstack.com/middleware/)
* [chi middlewares](https://github.com/go-chi/chi/tree/master/middleware)

Echo middlewares имеют другой интерфейс, поэтому их нельзя использовать 
в chi. В общем случае все middlewares, совместимые со стандартной 
библиотекой, можно применять с `chi` и `Echo`.

Чтобы использовать middleware, совместимое со стандартной библиотекой,
с `Echo`, вам нужно вызвать `echo.WrapMiddleware`:

```go
package main

import (
	"github.com/go-chi/chi/v5/middleware"
	"github.com/labstack/echo/v4"
)

// версия с echo
func main() {
	e := echo.New() 
	
	// Вы можете использовать middleware из chi в echo. 
	e.Use(
		echo.WrapMiddleware(middleware.BasicAuth("realm", map[string]string{
			"admin": "password",
		})), 
	)
	
	e.Logger.Fatal(e.Start(":8080"))
}
```

Если ни один из них не предоставляет middleware, которое вы ищете, можно 
поискать в [списке Awesome Go](https://github.com/avelino/awesome-go#middlewares). Все 
они будут совместимы с `chi`, `Echo` и серверами, созданными на базе только 
стандартной библиотеки. Вы также можете написать собственное middleware.
Посмотрите примеры middlewares, чтобы вдохновиться при создании своего!

### Отправка статического содержимого

Для отправки статического содержимого в Go вам не нужно использовать никакую 
библиотеку. Начиная с Go 1.16, вы можете легко [встраивать статические 
файлы в бинарные файлы Go](https://pkg.go.dev/embed).

Ниже показано как это сделать для Echo и chi:

```go
package main

import (
	"embed"
	"net/http"
	
	"github.com/go-chi/chi"
	"github.com/go-chi/chi/v5"
	"github.com/labstack/echo/v4"
)

// Ваши статические файлы должны находиться в каталоге static/,
// например static/index.html, static/main.js и т. д.
//
//go:embed static
var staticFs embed.FS

// версия для chi
func main() {
	r := chi.NewRouter()
	
	r.Handle("/static/*", http.StripPrefix("/", http.FileServer(http.FS(staticFs))))
	log.Fatal(http.ListenAndServe(":8080", r))
}

// версия для echo
func main() {
	e := echo.New()
	e.GET("/static/*", echo.WrapHandler(http.StripPrefix("/", http.FileServer(http.FS(staticFs)))))
	e.Logger.Fatal(e.Start(":8080"))
}
```

После запуска сервера ресурсы будут доступны по адресу 
`http://localhost:8080/static/index.html`, 
`http://localhost:8080/static/main.js` и т. д.

> ❌ Антипаттерн: не используйте библиотеки без имени для тривиальных 
> функций.
> 
> Вы помните JavaScript библиотеку `leftpad`? Она состояла из 11 строк кода,
> добавляющих отступ слева в начале строки.
> 
> В какой-то момент автор решил удалить эту библиотеку. В этом не было бы
> ничего страшного, если бы не зависимость от неё тысяч проектов, включая 
> Node и Babel.
> 
> Отправка статического содержимого с Вашего веб-сервера — одна из таких
> тривиальных функций.

### OpenAPI

Никто не любит поддерживать API контракты вручную. Раздражает и 
контрпродуктивно сохранять в актуальном состоянии несколько 
однообразных, не интересных JSON. OpenAPI решает эту проблему с помощью 
JavaScript HTTP-клиента и Go HTTP-сервера, созданных на основе 
предоставленной спецификации.

Вот так выглядит [пример спецификации](https://github.com/ThreeDotsLabs/wild-workouts-go-ddd-example/tree/a0a41253db96d46d75e7ff4c7e7f95848f47dcc3/api/openapi).
Если вы раньше не работали с OpenAPI, подробнее о нём можно прочитать в 
моей [предыдущей статье](https://threedots.tech/post/serverless-cloud-run-firebase-modern-go-application/#openapi-swagger-client).
Здесь я уделю внимание инструментам, которые мы рекомендуем использовать 
для кода, сгенерированного спецификацией OpenAPI.

### Генерация Go сервера и клиентов

Мы не рекомендуем использовать официальный генератор OpenAPI для Go
кода. Вместо этого мы рекомендуем инструмент `oapi-codegen` из-за более 
высокого качества сгенерированного кода. Он также имеет более функционален.

> ❌ **Антипаттерн: не пытайтесь генерировать OpenAPI спецификацию из Go кода**
> 
> Существуют инструменты, которые могут генерировать OpenAPI спецификацию 
> из Go кода. Мы не рекомендуем их использовать.
> 
> Полная спецификация OpenAPI очень обширна, и будет сложно сгенерировать 
> всё необходимое из Go кода. Вполне вероятно, что в какой-то момент вам 
> нужно будет что-то добавить в спецификацию OpenAPI, и это может быть 
> невозможно сделать из Go кода.
> 
> Гораздо проще осуществлять генерацию наоборот: получать Go код из 
> OpenAPI спецификации.

✅ deepmap/oapi-codegen [Страница на GitHub](https://github.com/deepmap/oapi-codegen) [Документация](https://github.com/deepmap/oapi-codegen#readme) [Примеры использования](part1.md#Публичное HTTP API)

oapi-codegen — отличный инструмент, который не только генерирует модели, 
но и полное определение [маршрутизатора](list-of-recommended-libraries.md#Маршрутизаторы), проверку 
заголовка и правильный парсинг параметров. Работает с [chi](https://threedots.tech/post/list-of-recommended-libraries/#chi) 
и [Echo](https://threedots.tech/post/list-of-recommended-libraries/#echo).

Чтобы сгенерировать сервер, выполните следующую команду:

```shell
oapi-codegen -generate types -o "<OUTPUT DIR>/openapi_types.gen.go" -package "<GO PACKAGE>" "api/openapi/service.yml"
oapi-codegen -generate <TYPE> -o "<OUTPUT DIR>/openapi_api.gen.go" -package "<GO PACKAGE>" "api/openapi/service.yml"
```

где `<TYPE>` для `chi` должно быть `chi-server`, а для `Echo` просто 
`server`.

Для генерации клиентов:

```shell
oapi-codegen -generate types -o "<OUTPUT DIR>/$service/openapi_types.gen.go" -package "<GO PACKAGE>" "api/openapi/service.yml"
oapi-codegen -generate client -o "<OUTPUT DIR>/$service/openapi_client_gen.go" -package "<GO PACKAGE>" "api/openapi/service.yml"
```

Не забудьте изменить `<GO PACKAGE>` на желаемое имя пакета Go и `<OUTPUT DIR>` 
на желаемый каталог, куда нужно сохранить результат выполнения команды. 😉

Ваша работа на стороне сервера заключается в том, чтобы просто 
реализовать интерфейс ServerInterface, например:

```go
// ServerInterface содержит все обработчики сервера.
type ServerInterface interface {
	
	// (GET /trainer/calendar)
	GetTrainerAvailableHours(w http.ResponseWriter, r *http.Request, params GetTrainerAvailableHoursParams)

	// (PUT /trainer/calendar/make-hour-available)
	MakeHourAvailable(w http.ResponseWriter, r *http.Request)

	// (PUT /trainer/calendar/make-hour-unavailable)
	MakeHourUnavailable(w http.ResponseWriter, r *http.Request)
}
```

Весь исходный код: [github.com/ThreeDotsLabs/wild-workouts-go-ddd-example/internal/trainer/ports/openapi_api.gen.go](https://github.com/ThreeDotsLabs/wild-workouts-go-ddd-example/blob/b519c611e9d1248a149c89db9bcf879fd78b1e35/internal/trainer/ports/openapi_api.gen.go)

Реализацию можно посмотреть в [проекте Wild Workouts](https://github.com/ThreeDotsLabs/wild-workouts-go-ddd-example).

### Бонус: клиент для JavaScript/TypeScript

Даже несмотря на то, что это список рекомендуемых библиотек на языке Go, 
вам может понадобиться сгенерировать код для браузера.

✅ openapi-generator-cli [Страница на GitHub](https://github.com/OpenAPITools/openapi-generator-cli) [Документация](https://github.com/OpenAPITools/openapi-generator-cli#readme)

В этом случае мы также рекомендуем неофициальную библиотеку вместо 
официальной.

В отличие от `oapi-codegen`, `openapi-generator-cli` — это инструмент, 
написанный на Java. Чтобы избежать проблем, связанных с JVM, мы 
рекомендуем генерировать клиентов с помощью Docker:

```shell
docker run --rm --env "JAVA_OPTS=-Dlog.level=error" -v "${PWD}:/local" \
  "openapitools/openapi-generator-cli:v6.2.1" generate \
  -i "/local/api/openapi/service.yml" \
  -g javascript \
  -o "/local/web/src/clients/service"
```

Предполагается, что спецификация доступна локально по следующему пути
`api/openapi/service.yml`.

Вы также можете использовать `openapi-generator-cli` для TypeScript 
и других языков.

## Альтернативные виды взаимодействия

### gRPC

gRPC — это технология, которая может помочь вам в создании надежной
внутреннего взаимодействия между вашими сервисами (но не только!).

Я уже подробно описал, почему [стоит использовать gRPC для внутреннего
взаимодействия](part3.md) и как это сделать.

Я не буду повторяться здесь и сосредоточусь на инструментах, которые 
вам нужны.

При использовании gRPC у вас нет выбора как создавать сервер и клиент: 
вы должны использовать официальные инструменты. Хорошей новостью 
является то, что вам больше ничего не нужно, потому что они делают 
свою работу хорошо!

✅ protoc [Документация](https://grpc.io/docs/)

Чтобы сгенерировать Go код из файлов `.proto`, вам необходимо установить
[protoc](https://grpc.io/docs/protoc-installation/) и 
[плагин protoc Go](https://grpc.io/docs/quickstart/go/).

Список поддерживаемых типов можно найти в [спецификации языка
Protocol Buffers версии 3](https://developers.google.com/protocol-buffers/docs/reference/proto3-spec#fields). Более 
сложные встроенные типы, такие как Timestamp, можно найти в [списке часто
используемых типов](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf).

### Обмен сообщениями

✅ Watermill  [Страница на GitHub](https://github.com/ThreeDotsLabs/watermill) [Документация](https://watermill.io/) [Примеры использования](https://github.com/ThreeDotsLabs/watermill/tree/master/_examples)

Около четырех лет назад, работая над одним из наших проектов, мы 
обнаружили, что не существует библиотеки, которая могла бы упростить 
создание приложений, управляемых на основе сообщениями или событиями. 
Чтобы облегчить себе жизнь, мы решили написать библиотеку, которая 
позволит нам писать код, управляемый событиями, так же легко, как и
HTTP-сервисы. Так возник Watermill.

Сегодня Watermill — одна из самых популярных библиотек Go с почти 5 
тысячами звезд GitHub, +35 участниками и 10 официально поддерживаемыми
издателями/подписчиками.

Обычно библиотеки брокеров сообщений очень низкоуровневые. С Watermill
публикацию сообщений можно осуществить вот так просто следующим образом:

```shell
publisher.Publish("example.topic", msg)
```

И подписку как:

```shell
messages, err := subscriber.Subscribe(ctx, "example.topic")
if err != nil {
	panic(err)
}

for msg := range messages {
	fmt.Printf("received message: %s, payload: %s\n", msg.UUID, string(msg.Payload))
	msg.Ack()
}
```

По сравнению с использованием только библиотеки брокера сообщений, 
Watermill обеспечивает поддержку некоторого функционала более высокого 
уровня, такого как [middlewares](https://watermill.io/docs/middlewares/), 
[поддержка CQRS](https://watermill.io/docs/cqrs/) или компонент для [пересылки 
событий](https://watermill.io/docs/forwarder/) (который можно использовать
для потоковой передачи ваших сообщений из базы данных SQL в брокер
сообщений).

Сегодня Watermill официально поддерживает следующие брокеры сообщений:
[Kafka](https://watermill.io/pubsubs/kafka/), 
[GCP Pub/Sub](https://watermill.io/pubsubs/googlecloud/), 
[NATS](https://watermill.io/pubsubs/nats/), 
[RabbitMQ](https://watermill.io/pubsubs/amqp/) (Pub/Sub). Он также может прослушивать 
и отправлять события в виде [HTTP хуков](https://watermill.io/pubsubs/http/) из 
таких баз данных, как [MySQL/Postgres](https://watermill.io/pubsubs/sql/), 
[BoltDB](https://watermill.io/pubsubs/bolt/) или [Firestore](https://watermill.io/pubsubs/firestore/). Он 
также может работать с [издателем/подписчиком, основанном 
на Go-канале в памяти](https://watermill.io/pubsubs/gochannel/).

## База данных

### SQL

Не существует универсального решения для взаимодействия с SQL базами 
данных. Причина проста: это сильно зависит от того, какие данные вы 
храните.

В некоторых проектах модели данных относительно просты. В некоторых 
они очень сложны. Поэтому я могу порекомендовать две библиотеки. 
Вы должны выбрать один из них, исходя из требований вашего проекта.

Для проектов с простыми моделями данных следует обратить внимание на 
`sqlx`. Для более сложных — вам следует взглянуть на `SQLBoiler`.

> ✅ **Тактика: используйте ORM**
> 
> Я все чаще слышу, что использовать ORM — не очень хорошая идея. Я 
> понимаю причину такого мышления: многие люди страдают от неправильного
> использования ORM.
> 
> Это как с ножом: у меня есть очень острый японский нож, без которого я не
> представляю себе готовку. С другой стороны, мне нужно быть очень 
> осторожным при его использовании. Но этот факт не делает этот нож плохим 
> инструментом! Если вы используете его правильно, то он намного упрощает 
> вашу жизнь. Та же ситуация с ORM. Написание запросов вручную может 
> занять много времени и привести к ошибкам, если ваши модели сложны. ORM
> были изобретены для решения этой проблемы.
> 
> Если у вас существует неудачный опыт использования ORM, вам следует 
> прочитать статью [Что нужно знать о DRY](part5.md). Тактика, 
> представленная в > этой статье, поможет вам избежать всех 
> распространенных проблем с ORM.

> ❌ **Антипаттерн: избегайте слабо типизированных ORM
> 
> Большинство ORM сильно зависят от рефлексии и `interface{}/any`. Система 
> типов — одна из самых сильных сторон Go. Она помогает вам эффективно 
> создавать приложения. Отказ от строгой типизации делает ваше приложение 
> более подверженным ошибкам.

✅ sqlx [Страница на GitHub](https://github.com/jmoiron/sqlx) [Документация](http://jmoiron.github.io/sqlx/)

Пакет `database/sql` стандартной библиотеки довольно низкоуровневый. 
`sqlx` предоставляет более удобный и мощный API для работы с базами 
данных. Он содержит вспомогательные функции для общих задач, таких как 
вставка и запрос данных, а также поддерживает более продвинутых функций, 
таких как параметризованные запросы и транзакции. `sqlx` также имеет 
более продвинутую поддержку демаршалинга данных (например, в структуры,
списки структур, json данные и т. д.). В качестве приятного бонуса 
интерфейс `sqlx` совместим с интерфейсами из `database/sql`.

Но несмотря на то, что `sqlx` — отличная библиотека, она хорошо работает с 
относительно простыми моделями баз данных. С какого-то определенного 
уровня сложности вам следует подумать о переходе на ORM.

✅ SQLBoiler [Страница на GitHub](https://github.com/volatiletech/sqlboiler) [Документация](https://github.com/volatiletech/sqlboiler#table-of-contents) [Примеры использования](https://github.com/volatiletech/sqlboiler#features--examples)

Пока единственная ORM, полностью удовлетворяющая нашим требованиям, — это 
SQLBoiler. Поначалу вас может удивить то, как вы определяете модели
SQLBoiler. Большинство ORM генерируют схему базы данных из ваших Go
моделей. SQLBoiler делает обратное: он генерирует модели Go из схемы 
вашей базы данных.

Этот подход имеет множество преимуществ. Одной из наиболее важных 
особенностей является более строгая типизация, чем в других 
библиотеках. Благодаря этому во время компиляции выполняется множество 
проверок. Вам не нужно зависеть от тонны рефлексий и магических дескрипторов 
структур. В большинстве случаев, пока код компилируется, он будет 
работать правильно.

Генерация кода из схемы базы данных помогает при миграции из 
существующей базы данных, поскольку вам не нужно переписывать модели 
БД: SQLBoiler генерирует их за вас. Поэтому, если вы начнёте с `sqlx`, а
затем перейдете на `SQLBoiler`, то миграция будет довольно простой.

SQLBoiler поддерживает PostgreSQL, MySQL, MSSQLServer 2012+, SQLite3
и CockroachDB.

> ❌ **Антипаттерн: Использование моделей баз данных в ответах, 
> возвращаемых API**
> 
> Если вы только не пишете простейшее CRUD-приложение (а, скорее всего, 
> это не так), вам не следует связывать свои модели базы данных с ответами,
> возвращаемыми API.
> 
> В какой-то момент в проекте могут появиться требования, которые заставят
> вас возвращать данные в формате, отличном от формата, использующимся в 
> базе данных. Вместо того чтобы пытаться следовать DRY любой ценой, 
> самое время разделить ваши модели.
> 
> Подробнее об этом можно прочитать в статье [Бизнес-приложения на Go: 
> что нужно знать о DRY](part5.md) и [Распространенные антипаттерны в 
> веб-приложениях на Go](part14-2.md).

### Миграции

`SQLBoiler` и `sqlx` не предоставляют готовой поддержки миграции. Это 
нормально, потому что вас не заставляют использовать какое-то 
конкретное решение.

В своих последних проектах я использовал и `sql-migrate`, и `goose`, 
и остался им доволен.

✅ sql-migrate [Страница на GitHub](https://github.com/rubenv/sql-migrate) [Документация](https://github.com/rubenv/sql-migrate#readme)
✅ goose [Страница на GitHub](https://github.com/pressly/goose) [Документация](https://pkg.go.dev/github.com/pressly/goose)

Нам нравятся `sql-migrate` и `goose` за их простоту и гибкость. 
`sql-migrate` и `goose` можно запускать как CLI инструменты и как часть 
вашего сервиса.

Мне нравится встраивать его в бинарный файл сервиса. Благодаря этому 
миграция выполняется при старте сервиса и упрощает настройку. В этом 
случае их также намного проще запускать. Например, `sql-migrate` с
помощью `go:embed`:

```go
// migrations/run.go
package migrations

import (
	"database/sql"
	"embed"
	
	migrate "github.com/rubenv/sql-migrate"
)

//go:embed *
var migrationsFiles embed.FS

func Run(postgresConn string) error {
	db, err := sql.Open("postgres", postgresConn)
	if err != nil {
		return err
	}
	
	migrations := &migrate.EmbedFileSystemMigrationSource{
		FileSystem: migrationsFiles, 
		Root:       ".",
	}
	
	if _, err := migrate.Exec(db, "postgres", migrations, migrate.Up); err != nil {
		return err
	}
	
	return nil
}
```

Поместите свои миграции в `migrations/`, например: `migrations/1_init.sql`,
`migrations/2_alter_some_table.sql` и т. д. Затем запустите функцию 
`Run` в вашем файле `main`.

## Наблюдаемость

### Логирование

Логгер стандартной библиотеки не предоставляет таких важных функций, как 
уровни важности логирования и форматирование вывода.

Для логирования можем порекомендовать две библиотеки: `Logrus` и `zap`. 
В отличие от `zap`, `Logrus` предоставляет немного более удобный 
пользовательский API, но `zap` работает быстрее.

Вы можете просмотреть подробные бенчмарки в файле 
[Readme zap](https://github.com/uber-go/zap#performance).

> **Антипаттерн: Вы не должны выбирать инструменты, основанные только на
> бенчмарках **
> 
> Некоторые разработчики склонны выбирать библиотеки на основе 
> результатов бенчмарков. Это рискованный подход, потому что чрезмерная 
> оптимизация производительности приводит к ухудшению API и ограниченному
> набору функций. В большинстве случаев различия в производительности 
> незначительны в реальных сценариях использования.
> 
> Даже если для некоторых приложений это может быть важно, для 
> большинства приложений это не имеет большого значения. Выполнение всего 
> лишь одного дополнительного запроса к базе данных или масштабирование
> сервиса путём увеличения выделяемых ему ресурсов может значительно
> повысить производительность.
> 
> Если производительность для вас не так критична, вам следует 
> отдать предпочтение другим характеристикам, таким как простота 
> использования и число предоставляемых функций.

✅ Logrus [Страница на GitHub](https://github.com/sirupsen/logrus) [Документация](https://pkg.go.dev/github.com/sirupsen/logrus)
✅ zap [Страница на GitHub](https://github.com/uber-go/zap) [Документация](http://pkg.go.dev/github.com/uber-go/zap)

### Метрики и трассировка

✅ opencensus-go [Страница на GitHub](https://github.com/census-instrumentation/opencensus-go) [Документация](https://opencensus.io/) 

OpenCensus Go — это библиотека, которая помогает добавлять метрики и 
отлаживать ваши конечные точки или запросы к базе данных. Интеграция 
использует шаблоны middleware/декоратора и не требует большого 
количества пользовательского кода. Он поддерживает [конечные точки HTTP](https://pkg.go.dev/go.opencensus.io/plugin/ochttp), 
[конечные точки gRPC](https://pkg.go.dev/go.opencensus.io/plugin/ocgrpc), 
[SQL базы данных](https://pkg.go.dev/github.com/opencensus-integrations/ocsql), 
[MongoDB](https://pkg.go.dev/github.com/orijtech/mongo-go-driver) и т. д.

Вы можете экспортировать трассировки и метрики в Prometheus, 
OpenZipkin, GCP Stackdriver Monitoring, Jaeger, AWS X-Ray, Datadog,
Graphite, Honeycomb или New Relic.

## Конфигурация

Стандартная библиотека Go не осуществляет поддержку дополнительных 
параметров конфигурации, если требования к ним превышают возможности 
[пакета flag](https://pkg.go.dev/flag). Даже если его достаточно для 
простых CLI инструментов, вам может понадобиться больше возможностей
при создании сервисов.

### Переменные окружения

✅ caarlos0/env [Страница на GitHub](https://github.com/caarlos0/env) [Документация](https://pkg.go.dev/github.com/caarlos0/env)

Эта библиотека содержит всё необходимое для конфигурации большинства 
приложений. По сравнению со стандартной библиотекой, она поддерживает 
загрузку переменных окружения в структуры и настройку переменных окружения по 
умолчанию. Это помогает сэкономить время, которое тратится на написание 
однотипных проверок, для больших конфигураций. Она также поддерживает 
встроенные структуры, поэтому вы можете создать большую сложную 
конфигурацию из независимых компонентов.

> ✅ Тактика: используйте переменные окружения для конфигурации ваших 
> сервисов
> 
> Для большинства приложений переменных окружения должно быть достаточно 
> для конфигурации.
> 
> Конфигурация — это место, где вы должны хранить секретную информацию и 
> параметры, которые отличаются для разных окружений. Если ваша 
> конфигурация очень большая и не часто меняется, возможно, стоит её 
> жестко запрограммировать. Это гораздо более прагматично, чем иметь 
> десятки никогда не меняющихся параметров конфигурации.

#### Мультиформатная конфигурация

✅ koanf [Страница на GitHub](https://github.com/knadh/koanf) [Документация](https://pkg.go.dev/github.com/knadh/koanf)

Koanf — отличный инструмент, если для вашего проекта требуется поддержка 
нескольких форматов конфигурации. Часто такое бывает, когда пишете 
инструменты, которые используются другими разработчиками (например, 
CLI инструменты).

Это моя последняя находка. По сравнению с другими [более популярными 
библиотеками](https://github.com/knadh/koanf#alternative-to-viper), koanf 
просто правильно загружает мультиформатную конфигурацию. Бонусные баллы 
библиотека получает за хорошую абстракцию, позволяющую расширить 
синтаксический парсинг и загрузку параметров.

Koanf поддерживает наиболее важные форматы конфигурации, такие как 
`json`, `yaml`, `dotenv`, переменные окружения или `hcl`. Их можно 
загрузить из файловой системы, флагов и нескольких внешних источников, 
таких как `s3`, `vault`, `etcd` или `consul`.

## Создание интерфейса командной строки

### Создание CLI библиотек

✅ urfave/cli [Страница на GitHub](https://github.com/urfave/cli/) [Документация](https://cli.urfave.org/) [Примеры использования](https://cli.urfave.org/v2/examples/greet/)

Нам нравится `urfave/cli` из-за его простого интерфейса и расширяемости. 
Мы использовали его в нескольких проектах без каких-либо проблем.

По сравнению с другими альтернативами она предоставляет достаточно большой
набор функций, сохраняя при этом легковесность библиотеки.

## Тестирование

### Утверждения

✅ testify [Страница на GitHub](https://github.com/stretchr/testify) [Документация](https://pkg.go.dev/github.com/stretchr/testify)

`testify` по сути стала стандартной библиотекой утверждений, и я видел её 
в каждом проекте, над которым работал. Она позволяет создавать утверждения 
для наиболее распространенных случаев, а также для некоторых более сложных.
Одной из ключевых особенностей `testify` являются понятные человеку 
сообщения для всех случаев, когда утверждения не выполняются. Это 
значительно ускоряет написание и отладку тестов.

Библиотека позволяет создавать утверждения двумя способами:

* с помощью `assert` из `github.com/stretchr/testify/assert` — тест 
  продолжается после сбоя. Вы должны использовать его, когда хотите увидеть 
  несколько ошибок (не только первую). Работает при вызове в горутине.
* с помощью `require` из `github.com/stretchr/testify/require` — тест 
  прерывается после сбоя. Вы должны использовать его, когда какое-то 
  критическое условие не было выполнено и продолжать не имеет смысла 
  (например: не удалось сохранить информацию в базу данных). Не работает
  при вызове в горутине.

Некоторые примеры утверждений:

* [Equal](https://pkg.go.dev/github.com/stretchr/testify/assert#Equal) — его 
  обычно достаточно в большинстве случаев
* [Eventually](https://pkg.go.dev/github.com/stretchr/testify/assert#Eventually) — может 
  пригодиться для утверждения асинхронных условий
* [ElementsMatch](https://pkg.go.dev/github.com/stretchr/testify/assert#ElementsMatch) — может 
  пригодиться при сравнении не отсортированных срезов
* [WithinDuration](https://pkg.go.dev/github.com/stretchr/testify/assert#WithinDuration) — может 
  пригодиться при сравнении моментов времени, которые часто не могут 
  идеально совпадать
* [ErrorIs](https://pkg.go.dev/github.com/stretchr/testify/assert#ErrorIs)
* [JSONEq](https://pkg.go.dev/github.com/stretchr/testify/assert#JSONEq)
* [Panics](https://pkg.go.dev/github.com/stretchr/testify/assert#Panics)

> ✅ **Тактика: используйте сообщения с `assert` только в там, где они 
> действительно необходимы**
>  
> Я встречал людей, которые одержимо пишут сообщения для всех случаев, 
> когда утверждения не выполняются.
> 
> Например:
> 
> ```go
> assert.Equal(t, 123, 321, "123 is not equal to 321")
> ```
> 
> выдаст:
> 
> ```shell
> Error:         Not equal: 
>                 expected: 123
>                 actual  : 321
> Test:          TestEqual
> Messages:      123 is not equal to 321
> ```
> 
> Как видите сообщение не добавляет никакой дополнительной информации к 
> той, которую уже вывела `testify`. Это может быть даже вредно, потому 
> что возможно в будущем вам нужно будет тратить много времени, чтобы 
> поддерживать эти сообщения в актуальном состоянии.
> 
> В большинстве случаев сообщения, выдаваемого testify будет достаточно. Если
> тест не пройден человек, увидевший ошибку, перейдет к этому тесту и поймет
> причину из его кода.

> ✅ **Тактика: не пишите базовые утверждения вручную**
> 
> Многие люди доказывают, что нужно прописывать все утверждения вручную.
> В конечном итоге это не даст вам каких-либо больших преимуществ.
> 
> testify также достаточно умна и может вывести разницу между ожидаемым 
> и фактическим значением.
> 
> Например:
> 
> ```go
> assert.Equal(t, []byte("foo bar baz"), []byte("foo bar 42"))
> ```
> 
> ```shell
> Error:         Not equal: 
>                expected: []byte{0x66, 0x6f, 0x6f, 0x20, 0x62, 0x61, 0x72, 0x20, 0x62, 0x61, 0x7a}
>                actual  : []byte{0x66, 0x6f, 0x6f, 0x20, 0x62, 0x61, 0x72, 0x20, 0x34, 0x32}
>                  
>                Diff:
>                --- Expected
>                +++ Actual
>                @@ -1,3 +1,3 @@
>                -([]uint8) (len=11) {
>                - 00000000  66 6f 6f 20 62 61 72 20  62 61 7a                 |foo bar baz|
>                +([]uint8) (len=10) {
>                + 00000000  66 6f 6f 20 62 61 72 20  34 32                    |foo bar 42|
>                }
> Test:          TestEqual
> --- FAIL: TestEqual (0.00s)
> 
> Expected :[]byte{0x66, 0x6f, 0x6f, 0x20, 0x62, 0x61, 0x72, 0x20, 0x62, 0x61, 0x7a}
> Actual   :[]byte{0x66, 0x6f, 0x6f, 0x20, 0x62, 0x61, 0x72, 0x20, 0x34, 0x32}
> ```
> 
> Нет смысла изобретать велосипед и писать всё с нуля.

> ❌ **Анти-шаблон: не используйте наборы тестов от testify**
> 
> Testify — отличная библиотека для утверждений, но мы не рекомендуем её 
> наборы тестов. Они не поддерживают параллельные подтесты. Они могут 
> подойти для unit-тестов, но для интеграционных/API/E2E-тестов их 
> использование может привести к проблемам.
> 
> Стандартная библиотека может реализовать большинство функций, 
> предоставляемых наборами тестов `testify`. Конкретные примеры вы 
> можете посмотреть в [этой статье, посвященной тестированию 
> микросервисов](https://threedots.tech/post/microservices-test-architecture/#keeping-integration-tests-stable-and-fast).

✅ go-cmp [Страница на GitHub](https://github.com/google/go-cmp) [Документация](https://pkg.go.dev/github.com/google/go-cmp) [Примеры использования 1](https://github.com/google/go-cmp/blob/master/cmp/example_test.go) [Примеры использования 2](https://github.com/google/go-cmp/blob/master/cmp/cmpopts/example_test.go)

Иногда вы должны проверять сложную структуру в своих тестах, пропуская 
некоторые поля. Или структура содержит поля, которые нужно сравнивать 
определенным образом. Или вам нужно игнорировать порядок элементов в срезе
или разницу в моментах времени. Здесь вам может помочь `go-cmp`!

```go
import (
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
)

diff := cmp.Diff(
	want, 
	got, 
	// Поля FieldToIgnore и AnotherFieldToIgnore будут проигнорированы в 
	// структуре SomeStruct
	cmpopts.IgnoreFields(SomeStruct{}, "FieldToIgnore", "AnotherFieldToIgnore"),
   
	// при сравнении моментов времени обрезаем их до одной секунды
	// можно написать для любого типа
	opt := cmp.Comparer(func(x, y time.Time) bool {
		return x.Truncate(time.Second).Equal(y.Truncate(time.Second))
	})
   
	// сортируем все []int
	cmpopts.SortSlices(func(x, y int) bool {
		return x < y 
	}))
)

// cmp возвращает различия, если два объекта отличаются
// чтобы проверить, равны ли объекты, нужно протестировать пуст ли diff
assert.Empty(t, diff)
```

Чтобы просмотреть список всех доступных возможностей, я рекомендую 
прочитать документацию, сгенерированную `godoc`, к пакетам [cmp](https://pkg.go.dev/github.com/google/go-cmp/cmp) 
и [cmpopts](https://pkg.go.dev/github.com/google/go-cmp/cmp/cmpopts).

`go-cmp` также можно использовать вне тестов, но будьте осторожны — это ещё
один инструмент, который при безответственном использовании может 
навредить вашему проекту.

✅ gofakeit [Страница на GitHub](https://github.com/brianvoe/gofakeit) [Документация](https://pkg.go.dev/github.com/brianvoe/gofakeit)

Если вам нужны более реалистичные данные для ваших тестов, вам в
этом поможет `gofakeit`.

### Имитация

#### Пишите имитации вручную

_Изначально я порекомендовал здесь один популярный инструмент для имитаций. 
Но немного подумав, мы решили, что инструмент недостаточно хорош, 
чтобы рекомендовать его. Вместо этого рассмотрите альтернативную 
стратегию для имитаций_ 👇

> ✅ **Тактика: рассмотрите возможность написания имитаций вручную**
> 
> Даже если это звучит как пустая трата времени, нет ничего плохого в 
> самостоятельном написании имитаций. Объективно говоря, их написание 
> вручную не требует много времени и код получается компактным.
> В качестве бонуса это дает вам гораздо больше гибкости.
> 
> Вот как может выглядеть пример имитации:
> 
> ```go
> type BalanceUpdate struct {
>	  UserID       string
>	  AmountChange int
> }
>
> type UserServiceMock struct {
>     BalanceUpdates []BalanceUpdate
>     balanceUpdatesLock sync.Mutex
> }
>
> func (u *UserServiceMock) UpdateTrainingBalance(ctx context.Context, userID string, amountChange int) error {
>     u.balanceUpdatesLock.Lock()
>     defer u.balanceUpdatesLock.Unlock()
>
>     u.BalanceUpdates = append(u.BalanceUpdates, BalanceUpdate{userID, amountChange})
>     return nil
> }
> ```
> 
> На его написание у меня ушла буквально 1 минута.

> ✅ **Тактика: Старайтесь сохранять свои интерфейсы небольшими, чтобы их 
> было легче имитировать**
> 
> Трудно имитировать сложные типы вручную. Но если ваш интерфейс 
> настолько сложен, что вы не можете написать макет для него, вам 
> следует задать себе вопрос: должен ли он быть таким большим? Использование
> библиотек для имитаций скрывает реальную проблему.
> 
> Попробуйте упростить тип, который вы имитируете. Может пригодиться принцип 
> разделения интерфейсов? Возможно стоит разделить этот тип на несколько 
> меньших типов.
> 
> Это не только упростит ваши имитации, но и улучшит вашу кодовую базу.

## Разное

### Поддержка дополнительных типов

✅ google/uuid [Страница на GitHub](https://github.com/google/uuid) [Документация](https://pkg.go.dev/github.com/google/uuid)

Эта библиотека генерирует UUID.

✅ oklog/ulid [Страница на GitHub](https://github.com/oklog/ulid) [Документация](https://pkg.go.dev/github.com/oklog/ulid)

UUID [могут медленно сохраняться](https://www.percona.com/blog/2014/12/19/store-uuid-optimized-way/) в 
больших по объёму таблицах в реляционных базах данных. Решением может 
быть использование универсального уникального лексикографически 
сортируемого идентификатора: ULID. ULID совместимы с UUID, достаточно 
уникальны для больших по объёму таблиц и имеют более короткое строковое 
представление (Crockford base32). ULID лексикографически сортируются, 
благодаря чему создание индексов должно происходить намного быстрее.

> Стоит отметить, что UUID v6, v7 и v8 также будут лексикографически
> сортируемыми. Но их спецификация все ещё на стадии черновика на момент 
> выхода статьи. Если вы хотите попробовать UUID v6 или v7, вы можете 
> попробовать воспользоваться библиотекой [github.com/gofrs/uuid](https://github.com/gofrs/uuid/blob/e1079f31cfcadf78856b9866d15574dd6546e29b/uuid.go#L66), где 
> они уже реализованы.

✅ shopspring/decimal [Страница на GitHub](https://github.com/shopspring/decimal) [Документация](https://pkg.go.dev/github.com/shopspring/decimal)

В Go нет встроенной поддержки типа данных decimal. `shopspring/decimal` 
позволяет реализовать её. Мы использовали эту библиотеку пару лет для 
построения большой финансовой системы.

> ✅ Тактика: используйте тип данных decimal для денежных значений
> 
> Числа с плавающей запятой не предназначены для точного хранения 
> таких значений.
> 
> Например:
> 
> ```go
> fmt.Printf("%.16f", 12.1+0.03)
> 
> > Output: 12.1300000000000008
> ```
> 
> Чтобы убедиться, что ваши денежные расчеты верны (и вы не теряете и не
> получаете лишних центов при расчетах), мы рекомендуем использовать 
> тип decimal.
> 
> Также рекомендуется использовать строковое представление типа decimal
> вместо чисел с плавающей запятой при передаче информации (для событий, в  
> запросах и ответах API и т. д.).

### Ошибки

✅ hashicorp/go-multierror [Страница на GitHub](https://github.com/hashicorp/go-multierror) [Документация](https://pkg.go.dev/github.com/hashicorp/go-multierror)

Вам когда-нибудь приходилось обрабатывать ошибку во время обработки 
другой? `hashicorp/go-multierror` может помочь вам!

Она также полезна, если операция может вернуть несколько ошибок, и вы не
хотите возвращать только первую (например, валидация).

Примеры использования:

```go
func validate() {
	var resultErr error
	
	if err := validateFoo(); err != nil {
		resultErr = multierror.Append(resultErr, err)
	}
	if err := validateBar(); err != nil {
		resultErr = multierror.Append(resultErr, err)
	}
	
	return resultErr
}
```

или

```go
func ExecuteStuff() error {
	if err := makeStuff(); err != nil {
		if cleanupErr := cleanup(); cleanupErr != nil {
			err = multierror.Append(err, cleanupErr)
		}
		
		return err
	}
	
	return nil
}
```

_Примечание. В Go 1.20 [появится](https://github.com/golang/go/issues/53435) функция
`error.Join`. После выхода Go 1.20 вам стоит рассмотреть возможность её 
использования._

## Полезные инструменты

### Разное

✅ samber/lo [Страница на GitHub](https://github.com/samber/lo) [Документация](https://pkg.go.dev/github.com/samber/lo)

Библиотека Go в стиле Lodash, основанная на Go 1.18+ дженериках. Она может 
стать особенно полезно для вас, если вы переходите на Go с Python и вам не
хватает некоторых базовых функций для работы со срезами/картами.

Некоторые функции, которые я использую чаще всего:

* [Filter](https://pkg.go.dev/github.com/samber/lo#Filter)
* [Map](https://pkg.go.dev/github.com/samber/lo#Map)
* [Keys](https://pkg.go.dev/github.com/samber/lo#Keys)
* [Values](https://pkg.go.dev/github.com/samber/lo#Values)
* [Find](https://pkg.go.dev/github.com/samber/lo#Find)
* [Max](https://pkg.go.dev/github.com/samber/lo#Max)
* [Must](https://pkg.go.dev/github.com/samber/lo#Must) 😈 пожалуйста, 
  используйте её только для тестов или если у вас действительно есть 
  веская причина

Даже если кому-то это может показаться «неидиоматичным», я считаю её 
полезной в некоторых случаях. Это похоже на использование [ORM](list-of-recommended-libraries.md#sql) — пока 
такие библиотеки используются ответственно и не запутывают код, они 
полезны.

Но если вы поймаете себя при написании такого кода:

```go
lo.Map(
	lo.Filter(someSlice, func(v SomeType, _ int) bool {
		return v.IsSpecial
	}), 
	func(t SomeType, _ int) string {
		return t.SpecialName()
	},
)
```

… то намного лучше преобразовать его в простой, более читаемый цикл. 😉

✅ Task [Страница на GitHub](https://github.com/go-task/task) [Документация](https://taskfile.dev/)

На самом деле `Task` — это не библиотека Go, а инструмент, написанный на 
Go, который может быть полезно использовать для ваших проектов.

Это отличная альтернатива Makefile. Наиболее важные функции, которые он 
предоставляет:

* Параллельное выполнение задач (поддерживается 
  [зависимостями задач](https://taskfile.dev/usage/#task-dependencies))
* Предотвращение [ненужной работы](https://taskfile.dev/usage/#prevent-unnecessary-work)
* [Загрузка .env](https://taskfile.dev/usage/#env-files)
* [Динамические переменные](https://taskfile.dev/usage/#dynamic-variables)
* [Пересылка CLI аргументов](https://taskfile.dev/usage/#forwarding-cli-arguments-to-commands)
* [Шаблонизатор](https://taskfile.dev/usage/#gos-template-engine)

Это маст-хэв в каждом моём новом проекте.

### Перезагрузка кода «на лету»

✅ reflex [Страница на GitHub](https://github.com/cespare/reflex) [Документация](https://pkg.go.dev/github.com/cespare/reflex) [Пример использования](part0-4.md)

Go не обеспечивает перезагрузку кода «на лету» из коробки. Но вы можете 
быстро добиться этого с помощью библиотеки `reflex`.

Пару лет тому назад Милош написал статью, в которой показано, как 
создать [локальное окружение с помощью Docker и reflex](part0-4.md).

### Линтер

✅ golangci-lint [Страница на GitHub](https://github.com/golangci/golangci-lint) [Документация](https://golangci-lint.run/)

`golangci-lint` — это линтер, в котором объединено несколько линтеров, он 
запускает их параллельно и делает это очень быстро.

Вот [пример конфигурации](https://github.com/ThreeDotsLabs/wild-workouts-go-ddd-example/blob/b519c611e9d1248a149c89db9bcf879fd78b1e35/internal/trainer/.golangci.yml), которую 
мы используем в наших проектах.

✅ go-cleanarch [Страница на GitHub](https://github.com/roblaszczak/go-cleanarch) [Документация](https://pkg.go.dev/github.com/roblaszczak/go-cleanarch#section-readme)

Если вы применяете [чистую/гексагональную архитектуру](part9.md) в своем 
проекте, вы можете использовать этот линтер, чтобы убедиться, что 
Правило Инверсии Зависимостей и взаимодействие между пакетами соблюдены.

### Форматтеры

✅ go fmt

Стандартный модуль форматирования, предоставляемый инструментарием Go.

✅ goimports [Документация](https://pkg.go.dev/golang.org/x/tools/cmd/goimports)

Goimports делает все то же, что и go fmt, но также сортирует импорты в
ваших Go файлах. Это один из инструментов, который широко применяется в 
большинстве Go проектов.

Не все знают, но вы также можете отдельно сгруппировать свой локальный 
импорт с помощью флага `-local`.

```shell
goimports -local "github.com/ThreeDotsLabs/some-repository" -l -w .
```

✅ gofumpt [Страница на GitHub](https://github.com/mvdan/gofumpt) [Документация](https://pkg.go.dev/mvdan.cc/gofumpt#section-readme)

Подойдёт наиболее помешанным на форматировании фрикам! Делает ли всё, что 
умеют `go fmt` и `goimports` и многое другое!

Лично мне нравятся решения, которые использует при форматировании, `gofumpt`.

## Примеры проектов

### DDD и чистая архитектура

✅ Пример Go приложения с использованием предметно-ориентированного проектирования Wild Workouts [Страница на GitHub](https://github.com/ThreeDotsLabs/wild-workouts-go-ddd-example)

**Wild Workouts — это пример проекта на Go DDD с использованием 
предметно-ориентированного проектирования, созданный нами, чтобы 
показать, как создавать приложения Go, которые легко разрабатывать, 
поддерживать и с которыми интересно работать. В нём показан проект, 
разрабатываемый с течением времени и требующий решения сложных проблем.**
В отличие от других примеров проектов, он не был слепо скопирован с 
других языков.

Именно так мы ежедневно создаём наши сервисы. Настоятельно рекомендуем, 
если вы ищете шаблоны проектирования, которые позволят вам создавать 
более сложные проекты!

> **Антипаттерн: репозитории с примерами низкого качества**
> 
> Избегайте проектов, которые выглядят как копии, созданные с использованием
> других языков программирования и переписанные на Go.
>
> Люди, которые пишут такие «DDD» проекты, часто просто читают пару 
> статей о нём, не понимая его правильно и не используя в реальных 
> проектах. Если вы видите примеры предметно-ориентированного 
> проектирования/чистой архитектуры без инкапсулированных моделей 
> предметной области (с публичными полями) и с тегами json: бегите! 
> Это определенно не предметно-ориентированное проектирование и не 
> чистая архитектура.

### Общего назначения

✅ Современное Go приложение от Марка Саги-Казара [Страница на GitHub](https://github.com/sagikazarmark/modern-go-application)

Еще один пример репозитория, который мы можем порекомендовать. В нём не 
рассматриваются такие шаблоны, как предметно-ориентированное проектирование
или чистая архитектура, но делается акцент на таких аспектах 
инфраструктуры как наблюдаемость.

## Резюме

Можете ли вы посоветовать какую-нибудь библиотеку, которая здесь не 
указана? Пожалуйста, сообщите нам в [комментариях](https://threedots.tech/post/list-of-recommended-libraries/#disqus_thread)!