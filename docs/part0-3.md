# Автоматическое семантическое управление версиями в GitLab CI

[Данная статья является переводом. Оригинал можно найти по ссылке](https://threedots.tech/post/automatic-semantic-versioning-in-gitlab-ci/)

Милош Смолка. Технический руководитель [Karhoo](https://www.karhoo.com/). Соучредитель
[Three Dots Labs](https://threedotslabs.com/). Создатель [Watermill](https://github.com/ThreeDotsLabs/watermill).

В предыдущей статье я показал, как хранить все скрипты, используемые в CI, в 
одном репозитории. Давайте посмотрим, какие более продвинутые скрипты вы могли 
бы добавить туда.

На этот раз я хотел бы показать, как добавить автоматическое управление 
версиями в ваш конвейер. Вы также увидите, как отправлять коммиты в ваш 
репозиторий с помощью CI задач. Но сначала давайте начнем с предыстории.

## Настраиваем свой рабочий процесс

Одна из вещей, которые мне нравятся в GitLab, — это его гибкость для настройки 
собственного CI рабочего процесса. Делаете ли вы один релиз каждую неделю, раз
в два месяца, следуете [классическому gitflow](https://nvie.com/posts/a-successful-git-branching-model/) или практикуете непрерывное 
развертывание, это просто вопрос конфигурации.

Как сторонник принципов непрерывной доставки, я обычно придерживаюсь 
защищенной главной ветки и недолговечных функциональных веток, которые 
объединяются после код ревью. Каждый коммит на master автоматически 
развертывается в какой-то промежуточной среде (предпочтительно идентичной 
продакшен среде), а затем может быть вручную переведена в продакшен среду.
Если у вас есть солидный набор многоуровневых тестов, этот рабочий процесс 
позволит вам развертывать приложение несколько раз в день.

## Версии

Какой бы рабочий процесс вы ни выбрали, управление версиями вашего приложения 
становится необходимым на многих этапах конвейера. Например, очень важно точно
знать, до какой версии следует откатиться, если что-то пойдет не так. Вы всегда
должны иметь возможность быстро найти коммит для данного номера версии.

Какую систему управления версиями выбрать зависит от вашего рабочего процесса.
Я обычно придерживаюсь семантического управления версиями, так как оно кажется 
естественным и уже является стандартом для многих проектов, особенно для библиотек.
Таким образом, первый коммит в ветке master получит версию `1.0.0`, следующий — 
`1.0.1`, затем `1.0.2` и т. д. (в качестве альтернативы вы можете начать с `0.0.1` 
и считать `1.0.0` первым публичным релизом).

Где хранить версии? Несколько хороших практик из моего опыта:

1. Не храните его в коде или файле, добавленном в репозиторий.
2. **Теги Git** идеально подходят для привязки версий к коммитам.
3. Автоматизируйте их. Не тратьте время разработчиков на размышления о том, 
   какой номер версии выбрать.

Таким образом, вы хотите, чтобы в вашу CI систему была встроена автоматическая 
маркировка версий.

## Реализация

Существенной частью управления версиями является сценарий, который запускается 
для каждой задачи в ветке `master`. Этот скрипт должен взять самую последнюю 
версию, повысить её, добавить тег и отправить в удаленный репозиторий.

> Вероятно, вам не нужно генерировать версии в других ветках. Решить эту проблему
> можно несколькими способами, но это тема для другой статьи.

На этот раз я собираюсь использовать Python и [библиотеку python-semver](https://github.com/k-bx/python-semver).
Если вы предпочитаете bash, взгляните на [semver-tool](https://github.com/fsaintjacques/semver-tool).

Посмотрим, что должен делать скрипт.

## 1. Выбрать самую последнюю версию и повысить её. 

Это сделать достаточно просто. Вы можете извлечь самый последний тег, 
запустив `git describe --tags`. Затем можно использовать библиотеку `semver` для
повышения версии.

Наша основная функция может выглядеть примерно следующим образом 
([полный исходный код](https://gitlab.com/threedotslabs/ci-scripts/blob/master/common/gen-semver)):

```python
def main():
    try:
        latest = git("describe", "--tags").decode().strip()
    except subprocess.CalledProcessError:
        # No tags in the repository
        version = "1.0.0"
    else:
        # Skip already tagged commits
        if '-' not in latest:
            print(latest)
            return 0

        version = bump(latest)

    tag_repo(version)
    print(version)

    return 0
```

Однако существует одна загвоздка — как вы решите, будет ли повышаться патч, 
минорная или мажорная версия?

```python
def bump(latest):
    # TODO решить что повышать
    # Затем использовать bump_patch, bump_minor или bump_major
    return semver.bump_patch(latest)
```

Вам нужно будет как-то отметить это в коммите. Я не буду реализовывать это в 
примере для простоты, но вот несколько идей, которые могут сработать:

* повышать пат версию по умолчанию, так как это наиболее распространенная 
  операция.
* намерение изменить младшую или основную версию может быть прописано в 
  сообщении коммита, например, с помощью какой-либо фразы, такой как `#minor` 
  или `bump-minor`.
* подобным образом вы можете прикреплять метки к запросам на слияние, 
  называемые `bump-minor` и `bump-major`.
* вы можете придумать скрипт, который определяет, были ли внесены какие-либо 
  критические изменения или добавлены новые функции.
  
## 2. Добавьте новый тег и отправьте его в удаленный репозиторий.

### Аутентификация

Этот шаг требует, чтобы CI задача имела доступ на запись в репозиторий.
К сожалению, на данный момент GitLab по-прежнему [не поддерживает отправку 
изменений обратно в репозиторий](https://gitlab.com/gitlab-org/gitlab-ce/issues/18106) из
коробки. Токены развертывания, показанные в [предыдущем статье](https://threedots.tech/post/keeping-common-scripts-in-gitlab-ci/), 
здесь нельзя использовать, так как они разрешают доступ только для чтения.
Поэтому нам остаётся использовать [ключи для развертывания](https://gitlab.com/help/ssh/README).

Сначала сгенерируйте новый ключ на локальном компьютере (без фразы для пароля):

```shell
ssh-keygen -t rsa -b 4096
```

Добавьте публичную часть в качестве нового **ключа развертывания** в раздел
`Settings -> Repository`. Обязательно установите флажок «Доступ для записи 
разрешен».

![deploy-keys](images/part0-3/deploy-keys.png)

Добавьте приватную часть в качестве новой переменной в разделе CI/CD. Имя 
выберите сами; я буду использовать `SSH_PRIVATE_KEY`.

![variables](images/part0-3/variables.png)

После того, как вы сохранили ключи в GitLab, рекомендуется удалить файл 
закрытого ключа (или, что ещё лучше, `shred`).

Осталось только добавить ключ SSH в определение CI. Есть несколько способов 
сделать это, один из них выглядит так (измените gitlab.com на ваше имя хоста, 
если вы используете GitLab, размещенный на своём хостинге):

```shell
script:
  - mkdir -p ~/.ssh && chmod 700 ~/.ssh
  - ssh-keyscan gitlab.com >> ~/.ssh/known_hosts && chmod 644 ~/.ssh/known_hosts
  - eval $(ssh-agent -s)
  - ssh-add <(echo "$SSH_PRIVATE_KEY")
```

### Отправляем тег

Простой `git push` не сработает, так как репозиторий клонируется по 
HTTPS, а не по SSH. Самое простое решение — преобразовать удаленный URL-адрес 
push-уведомления с помощью регулярного выражения.

```python
def tag_repo(tag):
    url = os.environ["CI_REPOSITORY_URL"]

    # Преобразуем URL репозитория в SSH URL
    # Пример входных данных: https://gitlab-ci-token:xxxxxxxxxxxxxxxxxxxx@gitlab.com/threedotslabs/ci-examples.git
    # Пример выходных данных: git@gitlab.com:threedotslabs/ci-examples.git
    push_url = re.sub(r'.+@([^/]+)/', r'git@\1:', url)

    git("remote", "set-url", "--push", "origin", push_url)
    git("tag", tag)
    git("push", "origin", tag)
```

## 3. Передать информацию о версии в следующие шаги сборки.

Очень вероятно, что более чем одному задаче в вашем конвейере потребуется 
знать сгенерированную версию. Идиоматический способ добиться этого — передать 
файл с версией как `artifact`.

```
version:
  image: python:3.7-stretch
  stage: version
  script:
    - pip install semver
    - $SCRIPTS_DIR/common/gen-semver > version
  artifacts:
    paths:
      - version
  only:
    - branches

build:
  image: golang:1.11
  stage: build
  script:
    - export VERSION="unknown"
    - "[ -f ./version ] && export VERSION=$(cat ./version)"
    - $SCRIPTS_DIR/golang/build-semver . example-server main.Version "$VERSION"
  artifacts:
    paths:
      - bin/
  only:
    - branches
```

> Если вы пропустили [статью об общих скриптах](https://threedots.tech/post/keeping-common-scripts-in-gitlab-ci/) или не хотите их использовать,
> вы также можете закоммитить скрипт в репозитории своего приложения.

Следующие шаги теперь могут считывать файл `./version`. Вы также можете сделать
его более удобным с помощью однострочника, помещенного в before_script:

```shell
before_script:
  - [ -f ./version ] && export VERSION=$(cat ./version)
```

## Не запускайте сборку для тегов

Не забудьте задать соответствующую настройку `only` в вашем определении шага, 
иначе ваши автоматические пуши тегов приведут к созданию новых конвейеров. Ограничить
их `branches` должно быть достаточно:

```shell
only:
  - branches
```

## Что насчет журналов изменений?

Иногда генерируют версию на основе файла CHANGELOG в репозитории. Я не 
рекомендую этот подход, так как он вынуждает разработчиков придумывать
версии, дублирует сообщения коммитов и может привести к конфликтам слияния.

Вместо этого вы можете рассматривать сам git log как журнал изменений (сосредоточьтесь 
на [что-то значащих коммит сообщениях](https://chris.beams.io/posts/git-commit/)). С 
настроенным автоматическим управлением версиями у вас есть все, что вам нужно, 
в коммите — автор, дата, версия и сообщение. Пусть CI сгенерирует для вас файл 
журнала изменений и загружает его куда-нибудь для каждой новой версии.

## Заключение

Это всего лишь базовая настройка, которую можно подправить для более 
конкретных случаев. Напишите мне в Twitter, если у вас есть вопросы или вы 
хотите поделиться своим опытом создания версий.

Полноценные примеры можно увидеть здесь:

* [скрипт gen-semver](https://gitlab.com/threedotslabs/ci-scripts/blob/master/common/gen-semver)
* [скрипт build-semver](https://gitlab.com/threedotslabs/ci-scripts/blob/master/golang/build-semver)
* [определение .gitlab-ci.yaml](https://gitlab.com/threedotslabs/ci-examples/blob/master/.gitlab-ci.yml)

Внешние ссылки:

* [Семантическое управление версиями](https://semver.org/)
* Взгляните на инструмент [semantic-release](https://semantic-release.gitbook.io/), 
  чтобы сравнить некоторые идеи.