# Темные века программного обеспечения

Роберт Лащак. Главный инженер [Karhoo](https://www.karhoo.com/). Соучредитель
[Three Dots Labs](https://threedotslabs.com/).
Создатель [Watermill](https://github.com/ThreeDotsLabs/watermill).

Пару лет назад я работал в SaaS-компании, которая страдала от **всевозможных 
проблем с разработкой программного обеспечения.** Код был настолько сложен, что 
на добавление простых изменений могли уйти месяцы. Все задачи и масштаб 
проекта определял только руководитель проекта. Разработчики не понимали, какую 
проблему они решают. Без понимания ожиданий заказчика многие реализованные 
функции оказались бесполезными. Команда разработчиков также не смогла предложить 
лучших решений.

Несмотря на то, что у нас были микросервисы, внедрение одного изменения часто 
требовало внесения изменений в большинство сервисов. Архитектура была настолько 
сильно связана, что мы не могли развернуть эти «микросервисы» независимо друг 
от друга. Бизнес не понимал, почему добавление «одной кнопки» может занять два 
месяца. В конце концов, заинтересованные стороны перестали доверять команде 
разработчиков. Мы все были очень расстроены. **Но положение не было безнадежным.**

**Мне посчастливилось быть немного знакомым с предметно-ориентированным 
проектированием.** В то время я был далеко не специалистом в этой области. Но 
моих знаний хватило, чтобы помочь компании минимизировать и даже устранить 
большую часть упомянутых проблем.

Прошло какое-то время, а в других компаниях эти проблемы не исчезли. Даже если 
решение этих проблем существует и не является тайным знанием. Люди, кажется, 
не знают об этом. Может быть, это потому, что старые методы, такие как GRASP
(_1997_), SOLID (_2000_) или DDD (_Domain-Driven Design_) (2003), часто забываются 
или считаются устаревшими? Это напоминает мне ситуацию, случившуюся в 
исторические Темные века, когда древние знания были забыты. Точно так же мы 
можем использовать старые идеи. Они по-прежнему актуальны и могут решать 
современные проблемы, но их часто игнорируют. **Как будто мы живем в Темные века 
программного обеспечения.**

Другое сходство заключается в сосредоточении внимания на неправильных вещах. 
В исторические Темные века религия подавляла науку. В Темные века программного 
обеспечения инфраструктура подавляет важные методы проектирования программного 
обеспечения. Я не утверждаю, что религия не важна. Духовная жизнь очень важна, 
но не тогда, когда вы страдаете от голода и болезней. То же самое и с 
инфраструктурой. **Отличный кластер Kubernetes и самая модная инфраструктура 
микросервисов не помогут вам, если дизайн вашего программного обеспечения 
отстой.**

![have-fun](images/part14-1/at-least-we-had-fun.jpg)

Позвольте мне попробовать добавить в продакшен ещё один популярный и бесполезный
инструмент...

## Темные века программного обеспечения как системная проблема

**Темные века программного обеспечения — очень сильная самовоспроизводящаяся** 
система. Вы не можете решить системную проблему, не понимая общей картины.
_Системное мышление_ – это техника, которая помогает анализировать такой сложный 
комплекс вопросов. Я использовал эту технику, чтобы визуализировать Темные 
века программного обеспечения.

![guide](images/part14-1/system-thinking.jpg)

Полное руководство по созданию худшей команды.

[Масштабированная версия здесь](https://threedots.tech/post/software-dark-ages/system-thinking.jpg)

Здесь показан один большой цикл из элементов, которые ускоряют друг друга.
Без вмешательства проблемы становятся все больше и больше. Как предметно-ориентированное
программирование может это исправить?

В отличие от большинства известных гуру программирования, мы не хотим, чтобы 
вы просто поверили в нашу историю. Мы могли бы просто её придумать. **К счастью, 
мы можем объяснить, почему это работает с помощью науки.** Точнее, с помощью 
отличной книги _Ускоряйся! Наука DevOps. Как создавать и масштабировать 
высокопроизводительные цифровые организации_, основанной на научных исследованиях.
В исследовании, описанном в книге, упоминаются характеристики лучших и худших команд. 
Одним из наиболее важных факторов является слабосвязанная архитектура.

**Если вы думаете, что микросервисы помогут вам создать слабосвязанную 
архитектуру, вы сильно ошибаетесь.** Я несколько раз видел микросервисы, которые 
более связаны, чем монолит. Вот почему нам нужно нечто большее, чем просто 
инфраструктурные решения. Это момент, когда в игру вступает предметно-ориентированное
проектирование (DDD).

> Это ключевое архитектурное свойство позволяет командам разработчиков легко тестировать
> и развертывать отдельные компоненты или сервисы даже по мере роста организации 
> и количества эксплуатируемых ею систем, т. е. позволяет организациям повышать
> свою производительность по мере масштабирования.
> 
> (...) использование новейшей инновационной архитектуры микросервисов, 
> развернутой в контейнерах, не гарантирует более высокой производительности,
> если вы игнорируете эти требования.
> 
> (...)
> 
> Архитектурные подходы, реализующие эту стратегию, включают использование 
> ограниченных контекстов и API-интерфейсов как способа разделения больших 
> доменов на более мелкие, более слабо связанные единицы, а также использование
> тестовых дублеров и виртуализации как способа изолированного тестирования 
> сервисов или компонентов.
> 
> _Ускоряйся! Наука DevOps. Как создавать и масштабировать высокопроизводительные цифровые организации_

## Предметно-ориентированное проектирование не работает

Может быть, вы знаете кого-то, кто попробовал DDD, и у них это не сработало?

Может быть, вы работали с человеком, который плохо в этом разбирался, пытался 
форсировать эти методики, слишком все усложнял?

Может быть, вы видели в Твиттере, что какой-то известный инженер-программист 
сказал, что DDD не работает?

Может быть, для вас это легендарный Святой Грааль, когда кто-то утверждает, 
что работает на них, но его еще никто не видел.

![kinda](images/part14-1/we-know-what-we-are-doing.jpg)

Мы знаем что делаем... вроде бы.

Не будем забывать, что мы живем в Темные века программного обеспечения. Есть 
одна проблема с идеями из предыдущей эпохи — есть шанс, что некоторые люди 
могут пропустить начальную точку DDD. Это неудивительно в контексте 2003 
года, когда впервые был предложен DDD.

![2003](images/part14-1/ddd-2003.jpg)

DDD В 2003

Войти в мир DDD непросто. Во многих книгах и статьях отсутствуют самые важные 
пункты DDD из-за их чрезмерного упрощения. Они также часто объясняются на 
абстрактных примерах, оторванных от реальности. Также нередко можно увидеть 
слишком длинные и слишком сложные примеры, которые невозможно понять.

Позвольте мне попытаться объяснить DDD самым простым способом.

## От Темных веков к эпохе Возрождения

DDD методы можно разделить на две части. Тактические и стратегические шаблоны
проектирования. Шаблоны тактического предметно-ориентированного проектирования 
рассказывают о том, **как** реализовать решение в коде. В тактическом DDD нет ничего 
сложного — все дело в передовом опыте объектно-ориентированного 
программирования. Но прежде чем писать код, нужно знать, **что** реализовать.
Вот где в игру вступают стратегические шаблоны DDD.

Во многих источниках, описывающих DDD, тратят большую часть времени на описание 
тактических шаблонов. Иногда они даже пропускают стратегические шаблоны.
**Вы можете применять DDD, используя только стратегические шаблоны.** В некоторых 
проектах использование тактических шаблонов DDD даже излишне. К сожалению, 
**большинство людей делают совершенно противоположные вещи. Они используют 
только тактические шаблоны без стратегических. Это ужасно.**

Если бы кто-нибудь спросил меня, существует ли какая-нибудь универсальный способ
разработки программного обеспечения, я бы назвал только одного кандидата:
_стратегические шаблоны предметно-ориентированного проектирования_. Они помогают нам
получить ответ на вопросы:

* **какую проблему мы решаем?**
* **удовлетворит ли ваше решение владельцев бизнеса и ожидания пользователей?**
* **насколько сложен проект?**
* **какой функционал не является обязательным?**
* **как разделить сервисы, чтобы быстро осуществлять разработку в долгосрочной 
  перспективе?**
  
Эти вопросы важны при реализации нового проекта, добавлении нового функционала или 
выполнении рефакторинга. **Стратегические шаблоны DDD дают нам возможность 
последовательно и предсказуемо отвечать на эти вопросы.**

Некоторые программисты говорят мне, что они "просто программисты". Их не слишком
интересует, кто использует их программное обеспечение и почему. Они просто 
реализуют, скажем, задачи JIRA - создают сервисы с несколькими байтами на входе 
и несколькими байтами на выходе. Такое мышление приводит к большому разрыву 
между инженерами и их клиентами, чьи проблемы мы, как инженеры, пытаемся решить.
Без надлежащего общения гораздо сложнее создавать решения, которые должным 
образом помогают клиентам. В конце концов, это и является целью — не просто 
обрабатывать байты.

Заманчиво потратить небольшое количество времени на этап планирования проекта.
Чтобы начать писать код как можно раньше и закончить раньше. Когда у кого-то 
возникают такие желания, я люблю говорить, что «_1 день планирования может сэкономить
5 дней написания кода_». Незаданные вопросы не исчезнут волшебным образом.

Лучший способ преодолеть Темные века программного обеспечения — атаковать его с 
разных сторон. Давайте посмотрим, как DDD шаблоны могут атаковать систему.

![solved](images/part14-1/system-thinking-solved.jpg)

[Масштабированная версия здесь](https://threedots.tech/post/software-dark-ages/system-thinking-solved.jpg)

## Event Storming

Event Storming меняет правила игры для стратегических шаблонов DDD и разработки
программного обеспечения в целом. **Не могу поверить, почему его еще не используют
все команды разработчиков во всём мире.**

**Event Storming — это семинар, где люди, у которых есть вопросы
(часто разработчики), встречаются с людьми, имеющими ответы на них (часто 
владельцы бизнеса)**. Во время семинара они могут быстро изучить сложные 
предметные области бизнеса. Вначале вы сосредотачиваетесь на построении 
полностью рабочего процесса на основе _событий предметной области_ (оранжевые 
стикеры). Event Storming — очень гибкий метод. Благодаря ему вы можете 
проверить, соответствует ли ваше решение ожидаемым требованиям. Вы также можете 
изучить поток данных, потенциальные проблемы или UX в зависимости от цели семинара.

![event-storming](images/part14-1/event-storming.png)

Event Storming, которое мы провели в [Karhoo](https://www.karhoo.com/)

**Проверка того, что решение не имеет пробелов и соответствует тому, что просили 
пользователи, занимает несколько минут. Внесение изменений и проверка идей в 
разработанном и развернутом коде обходится намного дороже. Замена стикера на 
доске стоит очень дешево.**

Инженер-строитель или инженер-ракетчик может быстро увидеть результат ошибки.
Они могут увидеть, что что-то явно не так, еще до завершения процесса сборки.
С программным обеспечением все не так просто, потому что его нелегко увидеть.
Большинство наших критических решений никому не навредят. Проблемы с разработкой 
и поддержкой функционала не появятся за один день.

Event Storming работает, когда вы **планируете как большой проект, так и маленький.** 
Это просто вопрос того, сколько времени вы хотели бы потратить. Когда мы 
используем его для маленького проекта, это может занять от 10 минут до пары 
часов. Обычно мы тратим от одного до нескольких дней на семинары, где 
разрабатывается большой функционал.

После семинара у вас должны быть правильные ответы на вопросы:

* **какие проблемы вы пытаетесь решить** — вместо того, чтобы гадать, что может быть 
  полезно конечному пользователю или полагать, что _«мы все знаем лучше»_,
* **довольны ли владельцы бизнеса предложенным решением** - а не проверять это через 
  полгода после внедрения,
* **сложность проблемы легко видна** — становится ясно, почему добавление одной 
  кнопки может потребовать тонны работы,
* **первоначальная идея о том, как вы можете разделить свои микросервисы по 
  обязанностям** - вместо того, чтобы слепо группировать «похожие вещи».

В конце концов вам гораздо больше будут доверять **владельцы бизнеса**, потому что 
вы планируете решение **вместе**. Это гораздо лучший подход, чем изолированное 
написание кода в подвале.

Отличительной чертой Event Storming является то, что результат правильно 
проведенного семинара может быть отображен непосредственно в коде. Это должно 
помочь вам избежать многих дискуссий во время разработки и значительно ускорить 
вашу работу.

![event-to-code](images/part14-1/storming-to-code.jpg)

Преобразование Event Storming в непосредственный код.

Вы должны начать с четкой цели. Время может пролететь очень быстро и, прежде 
чем вы это узнаете, вы потратите полгода на проект только для того, чтобы 
обнаружить, что он никому не нужен. У вас был такой опыт? Это случается чаще, 
чем вы думаете, поэтому некоторые люди теряют доверие к «инженерам» и это может 
привести к тому, что мы станем разработчиками без какой-либо свободы действий.

Стандартный страх - это боязнь "потери" времени на проведение семинара. **Думать 
о времени для семинара как о потерянном - неправильный подход. Вместо этого 
вам следует подумать о преимуществах, которые вы потеряете, если не проведете
его.** Я слышал историю, когда проведение одного Event Storming семинара остановило
реализацию проекта на пару месяцев. Это может звучать плохо, но во время семинара
команда обнаружила, что текущие предположения совершенно неверны. Продолжение 
проекта привело бы к полному провалу. Даже если в краткосрочной перспективе семинар
казался тратой времени, компания избежала пары месяцев бесполезной разработки.

## Моделирование событий

В 2018 году Адам Димитрук предложил методику моделирования событий (Event Modeling). Обозначения 
и идея в значительной степени основаны на методе Event Storming, но добавлены 
несколько новых возможностей. Здесь также уделяется дополнительное внимание на UX
части семинара.

В целом, эти техники вполне совместимы. Даже если вы продолжите использовать
Event Storming, вы можете найти некоторые ценные подходы в методике моделирования 
событий (Event Modeling), которые можно использовать.

Больше об этой методике можно узнать на сайте [eventmodeling.org](https://eventmodeling.org/posts/what-is-event-modeling/).

![event-modeling](images/part14-1/event-modeling.jpg)

## Ограниченный контекст и границы транзакций (агрегаты)

**Ограниченный контекст — это еще один стратегический шаблон DDD, который 
помогает нам разделить большие модели на более мелкие логические части.**

Это ключ к **правильному** разделению сервисов. Если вам нужно затронуть половину 
системы, чтобы внедрить и протестировать новую функциональность, ваше разделение
неверно.

Альтернативой неправильному разделению является отсутствие разделения. Часто 
симптомом отсутствия разделения являются божественные объекты (огромные объекты, которые 
слишком много знают или слишком много делают). В этом случае изменения в 
первую очередь коснутся одного сервиса. Цена такого подхода — более высокий 
риск крупного системного сбоя и более высокая сложность изменений.

Другими словами – в обоих случаях будет сложнее развивать свой проект.

Отличный инструмент, помогающий в обнаружении _ограниченного контекста_ и 
_агрегатов_, — это (конечно же) Event Storming.

![storming](images/part14-1/storming.png)

Бумажный вариант Event Storming

В результате семинара вы сможете наглядно увидеть как вам следует разделить 
свои сервисы и точки взаимодействия между ними.

## Единый язык

**Единый язык — это стратегический шаблон DDD, который касается создания общего 
языка между разработчиками, операторами, владельцами бизнеса и пользователями.**
Это самый **недооцененный шаблон Стратегического DDD**. Потому что кого волнует 
язык, верно?

Мне потребовалось время, чтобы увидеть, **сколько проблем в общении между 
разработчиками и не разработчиками возникает из-за использования разного языка.**
И как это больно. Предлагаю и вам обратить на это внимание. Из-за недопонимания 
**разработчики не решают правильную проблему, поскольку они не понимают, чего 
от них ожидают.**

Вы бы удивились, если бы я сказал вам, что Event Storming поможет вам 
разработать единый язык? Проведение семинара вместе с владельцами бизнеса 
заставляет вас говорить с ними. **Трудно найти решение вместе, когда вы не можете 
понять друг друга.** Вот почему так важно присутствие ваших владельцев бизнеса 
на семинаре!

![storming-brainstorm](images/part14-1/storming-brainstorm.jpg)

![storming-flow](images/part14-1/storming-flow.jpg)

От мозгового штурма к диаграмме работы

## Решает ли DDD все проблемы?

Даже если DDD великолепен, он не решает всех проблем, которые у нас существуют.
Важно управлять своими ожиданиями. **Даже если мы используем эти техники на 
высоком уровне в моей команде, у нас все еще есть сомнения, достаточно ли хороша
созданная архитектура.** Иногда мы не знаем, как подойти к проблеме. Иногда мы 
возвращаемся от кода к этапу проектирования. Иногда мы принимаем плохие решения. 
**Все это совершенно нормальные ситуации. В мире нет команды без этих проблем.
Лучше предположить, что так и будет, и не удивляться.** Но мы знаем, что без DDD 
эти проблемы были бы гораздо более значительными.

При использовании DDD обращайте особое внимание на то, чего следует 
избегать:

* пытаться сразу охватить весь проект,
* писать код "на будущее",
* пытаться создавать что-либо идеальное,

Вместо этого вы должны:

* **сосредоточьтесь на создании MVP пользователю за короткое время** (под коротким 
  я подразумеваю скорее 1 месяц, чем 6 месяцев).
* **если вам нужно что-то реализовать «на будущее», потому что добавить потом 
  будет сложнее** — это очень плохой знак. Вы должны подумать о том, как 
  упростить его добавление позже.
* **смиритесь с тем, что даже если вы сделаете все возможное, ваш проект не 
  будет идеальным с самого начала** — гораздо лучше улучшать его со временем.

Некоторым командам может потребоваться много времени и сил, чтобы перейти на 
этот уровень. Но я могу пообещать вам из своего опыта, что это возможно. И 
удовольствие, которое вы снова получите от создания программного 
обеспечения, того стоит!

> Если вы считаете, что должны быть техническим лидером, чтобы предлагать 
> такие улучшения — вы ошибаетесь! В первые дни, когда я еще не был лидером, я 
> уже предлагал множество улучшений в командах, в которых работал. У вас должны 
> быть хорошие аргументы, когда вы что-то предлагаете вашим товарищами по 
> команде.
> 
> Мы всегда объясняем, «почему» методы работают в наших статьях. Когда вы 
> будете использовать эти аргументы, их должно быть достаточно, чтобы убедить их.
> Если это не сработает, потому что ваша команда не дальновидна, это хороший повод 
> подумать о смене работы.

## Эпоха Возрождения программного обеспечения

В рамках одной статьи сложно углубиться в представленные методики. Моя цель 
состояла скорее в том, чтобы вдохновить вас усомниться в статусе-кво. **Не так 
должна работать наша отрасль. Если вас не устраивает статус-кво, надеюсь, я 
вдохновил вас на изучение новых методик.** Это лучший способ борьбы с Темными 
веками программного обеспечения.

Если вы хотите узнать о тактических шаблонах DDD, вам следует ознакомиться с 
нашими [предыдущими статьями](https://threedots.tech/tags/ddd/).

Примеры написаны на Go, но их легко портировать на любой язык. Go также имеет 
очень низкий порог входа. Кто знает, может быть, это будет ваш новый любимый 
язык? 😉

Что насчет стратегических шаблонов DDD? Эта статья на самом деле является 
введением в следующую часть нашей серии статей. **В последующие месяцы мы 
подробно рассмотрим наиболее важные шаблоны стратегического DDD** на полностью 
работающем проекте, используемом в качестве примера.

### Кто ты в Темных веках программного обеспечения?

Просто обычный деревенщина, которая слепо следует правилам, навязанным другими?

Инквизиция, кто будет пытаться ненавидеть и душить любой нестандартный подход?

Алхимик, пытающийся создать золото? Даже если это не подтверждено наукой?

А может быть, вы тайно читаете запрещенные книги в своем подвале? Может быть, 
вы хотите вместе с нами закончить темные века программного обеспечения и 
начать эпоху возрождения?

Дайте нам знать об этом в комментариях!

Ссылки

* [GRASP](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design))
* [SOLID](https://en.wikipedia.org/wiki/SOLID)
* [Big Design Up Front](https://en.wikipedia.org/wiki/Big_Design_Up_Front)
* [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it)
* [Ускоряйся! Наука DevOps. Как создавать и масштабировать высокопроизводительные цифровые организации](https://www.amazon.com/Accelerate-Software-Performing-Technology-Organizations/dp/1942788339)
* [Божественный объект](https://en.wikipedia.org/wiki/God_object)

Используемая графика

[Сад земных наслаждений (триптих Босха)](https://commons.wikimedia.org/wiki/File:The_Garden_of_earthly_delights.jpg)
[Извлечение камня глупости (картина Босха)](https://commons.wikimedia.org/wiki/File:Cutting_the_Stone_(Bosch).jpg)
[Слайд из видео Эрика Эванса - Структуризация сложных программных систем](https://youtu.be/dnUFEg68ESM?t=1040)